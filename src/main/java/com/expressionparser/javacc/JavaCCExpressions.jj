PARSER_BEGIN(JavaCCExpressions)

package com.expressionparser.javacc;
public class JavaCCExpressions{ }

PARSER_END(JavaCCExpressions)

TOKEN : {
      < PLUS: "+" >
    | < MINUS: "-" >
    | < MUL: "*" >
    | < DIV: "/" >
    | < MOD: "%" >
    | < POWER: "^" >
    | < NOT: "!" >
    | < EQUALS: "=" >
    | < LESSTHAN: "<" >
    | < GREATERTHAN: ">" >
    | < LESSTHANEQUALS: "<=" >
    | < GREATERTHANEQUALS: ">=" >
    | < AND: "&&" >
    | < OR: "||" >
    | < LPAREN: "(" >
    | < RPAREN: ")" >
}

TOKEN : {
      < INT: (<DIGIT>)+ >
    | < FLOAT:
          (<DIGIT>)+ "." (<DIGIT>)*
        | "." (<DIGIT>)+
        | (<DIGIT>)+
      >
    | < #DIGIT: ["0" - "9"] >
}

SKIP : {
	" "
	| "\t"
	| "\r"
}

float Start():
{ float f = 0; }
{
    try {
        (
              f = Expression() <EOF>
            | <EOF>
        )
        { return f; }
    } catch(ParseException err) {
        error(err);
        return null;
    }
}

float Expression():
{ float f = 0; }
{
    try {
        f = OrExpression()
        { return f; }
    } catch(ParseException err) {
        error(err);
        return null;
    }
}

float OrExpression():
{ float f = 0, f1 = 0; }
{
    try {
        f = AndExpression()
        (
            <OR>
            f1 = AndExpression() { (f || f1) ? f = 1 : f = 0; }
        )*
        { return f; }
    } catch(ParseException err) {
        error(err);
        return null;
    }
}

float AndExpression():
{ float f = 0, f1 = 0; }
{
    try {
        f = EqualsExpression()
        (
            <AND>
            f1 = EqualsExpression()  { (f && f1) ? f = 1 : f = ; }
        )*
        { return f; }
    } catch(ParseException err) {
        error(err);
        return null;
    }
}

float EqualsExpression():
{ float f = 0, f1 = 0; }
{
    try {
        f = RelationalExpression()
        (
              <NOT> <EQUALS> f1 = RelationalExpression() { (f != f1) ? f = 1 : f = 0; }
            | <EQUALS> <EQUALS> f1 = RelationalExpression() { (f == f1) ? f = 1 : f = 0; }
        )*
        { return f; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float RelationalExpression():
{ float f = 0, f1 = 0; }
{
    try {
        f = AdditiveExpression()
        (
              <LESSTHAN> f1 = AdditiveExpression() { (f < f1) ? f = 1 : f = 0; }
            | <GREATERTHAN> f1 = AdditiveExpression() { (f > f1) ? f = 1 : f = 0; }
            | <LESSTHANEQUALS> f1 = AdditiveExpression() { (f <= f1) ? f = 1 : f = 0; }
            | <GREATERTHANEQUALS> f1 = AdditiveExpression(){ (f >= f1) ? f = 1 : f = 0; }
        )*
        { return f; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float AdditiveExpression():
{ float f = 0, f1 = 0; }
{
    try {
        f = MultiplicativeExpression()
        (
              <PLUS> f1 = MultiplicativeExpression() { f = f + f1; }
            | <MINUS> f1 = MultiplicativeExpression() { f = f - f1; }
        )*
        { return; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float MultiplicativeExpression():
{ float f = 0, f1 = 0; }
{
    try {
        f = UnaryExpression()
        (
              f1 = PowerExpression()
            | <MUL> f1 = UnaryExpression() { f = f * f1; }
            | <DIV> f1 = UnaryExpression() { f = f / f1; }
            | <MOD> f1 = UnaryExpression() { f = f % f1; }
        )*
        { return; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float UnaryExpression():
{ float f = 0; }
{
    try {
        (
              <PLUS> f = UnaryExpression()
            | <MINUS> f = UnaryExpression() { f = f * -1; }
            | <NOT> f = UnaryExpression() { f = 1 - f; }
            | f = PowerExpression()
        )
        { return f; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float PowerExpression():
{ float f = 0, f1 = 0; }
{
    try {
        f = Fragment()
        (
            <POWER> f1 = UnaryExpression() { f = pow(f, f1); }
        )?
        { return f; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float Fragment():
{ Token t; float f = 0;}
{
    try {
          t = <INT> { f = Float.parseFloat(t.image); }
        | t = <FLOAT> { f = Float.parseFloat(t.image); }
        | <LPAREN> f = Expression() <RPAREN>
        { return f; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

JAVACODE
void error(ParseException e) {
	Token t = e.currentToken.next;
}
