PARSER_BEGIN(JavaCCExpressions)

package com.expressionparser.javacc;
public class JavaCCExpressions{ }

PARSER_END(JavaCCExpressions)

TOKEN : {
      < PLUS: "+" >
    | < MINUS: "-" >
    | < MUL: "*" >
    | < DIV: "/" >
    | < MOD: "%" >
    | < POWER: "^" >
    | < NOT: "!" >
    | < EQUALS: "=" >
    | < LESSTHAN: "<" >
    | < GREATERTHAN: ">" >
    | < LESSTHANEQUALS: "<=" >
    | < GREATERTHANEQUALS: ">=" >
    | < AND: "&&" >
    | < OR: "||" >
    | < LPAREN: "(" >
    | < RPAREN: ")" >
}

TOKEN : {
      < INT: (<DIGIT>)+ >
    | < FLOAT:
          (<DIGIT>)+ "." (<DIGIT>)*
        | "." (<DIGIT>)+
        | (<DIGIT>)+
      >
    | < #DIGIT: ["0" - "9"] >
}

SKIP : {
	" "
	| "\t"
	| "\r"
}

float Start():
{ }
{
    try {
        (
              Expression() <EOF>
            | <EOF>
        )
        { return; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float Expression():
{ }
{
    try {
        OrExpression()
        { return; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float OrExpression():
{ }
{
    try {
        AndExpression()
        (
            <OR>
            AndExpression()
        )*
        { return; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float AndExpression():
{ }
{
    try {
        EqualsExpression()
        (
            <AND>
            EqualsExpression()
        )*
        { return; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float EqualsExpression():
{ }
{
    try {
        RelationalExpression()
        (
            (
                <NOT> <EQUALS>
                RelationalExpression()
            )
            | (
                <EQUALS> <EQUALS>
                RelationalExpression()
            )
        )*
        { return; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float RelationalExpression():
{ }
{
    try {
        AdditiveExpression()
        (
              <LESSTHAN> AdditiveExpression()
            | <GREATERTHAN> AdditiveExpression()
            | <LESSTHANEQUALS> AdditiveExpression()
            | <GREATERTHANEQUALS> AdditiveExpression()
        )*
        { return; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float AdditiveExpression():
{ }
{
    try {
        MultiplicativeExpression()
        (
            (
                <PLUS>
                MultiplicativeExpression()
            )
            | (
                <MINUS>
                MultiplicativeExpression()
            )
        )*
        { return; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float MultiplicativeExpression():
{ }
{
    try {
        UnaryExpression()
        (
              <MUL> UnaryExpression()
            | <DIV> UnaryExpression()
            | <MOD> UnaryExpression()
        )*
        { return; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float UnaryExpression():
{ }
{
    try {
        (
              <PLUS> UnaryExpression()
            | <MINUS> UnaryExpression()
            | <NOT> UnaryExpression()
            | PowerExpression()
        )
        { return; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float PowerExpression():
{ }
{
    try {
        Fragment()
        (
            <POWER> UnaryExpression()
        )?
        { return; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}

float Fragment():
{ }
{
    try {
          <INT>
        | <FLOAT>
        | <LPAREN> Expression() <RPAREN>
        { return; }
    } catch(ParseException e) {
        error(e);
        return null;
    }
}
